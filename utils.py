import math
import main
import diy
import settings
import network
import main

# contains helper functions

# Find optimal change in peramater p:
def delta_p(p_0,i_0,T,H,LR):
  r_s=0.0
  i=i_0

  while i<T:
    n=(C(p_0,i+1)-C(p_0,i))*(H**2)*T
    
    d=(C(p_0+H,i+H)-C(p_0+H,i))-(C(p_0,i+H)-C(p_0,i))
    
    r_s+=float(n/d)
    
    i+=1

  return r_s*LR

# Returns reward/loss given peramater p and iteration i:
def C(p,i):
  return main.convergence_set[p][i]


def sigmoid(x)->float:
  return (math.e**x)/((math.e**x)+1)

def lerp(A,B,t):
  return A + (B-A)*t


# uses current perameter value to determine next perameter value
def update_peramter(p_0):

  p_1 = delta_p(p_0, 0, settings.T, settings.H, settings.LR) + p_0

  return p_1


# compiles convergence/trial data for a series of models and peramater p.
def load_convergence_data(trial_model=network(settings.trial_model_schema), p=settings.P_0):

  convergence_data = []
  for sub_trial in range(settings.T):
    result = preform_sub_trial(trial_model)

    if diy.is_good(result):
      trial_model.birth(p)
    else:
      trial_model.birth(2*p)

    convergence_data.push(result)

  main.convergence_set[p] = convergence_data
  return trial_model

# preforms one sub trial and returns the result (loss/reward)
def preform_sub_trial(trial_model):

  state = diy.STATE_0

  while not diy.is_terminal_state(state):

    actions = diy.legal_actions(state)

    action_evaluations = {}

    for action in actions:
      temp_state = diy.preform_action(state, action)

      state_eval = trial_model.feed_forward(diy.data_process(temp_state))

      action_evaluations[action] = state_eval

    eval = max(action_evaluations.values())
    ideal_action = 0

    for k in action_evaluations:
      if action_evaluations[k] == eval:
        ideal_action = k
        break

    state = diy.preform_action(state, ideal_action)

  return diy.scoring(state)
